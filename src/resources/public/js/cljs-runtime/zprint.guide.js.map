{"version":3,"sources":["zprint/guide.cljc"],"mappings":"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","names":["var_args","G__49853","zprint.guide/rodguide","js/Error","rod-options","options","len","sexpr","zprint.guide.rodguide","cljs.core._EQ_","cljs.core/first","multi-arity-nl?","cljs.core.get","docstring?","cljs.core.nth","rest","cljs.core/nthnext","multi-arity?","cljs.core/vector?","cljs.core/next","rest-guide","cljs.core.repeat","cljs.core/count","cljs.core.into","and__5043__auto__","cljs.core.interleave","cljs.core.conj","guide","G__49863","option-map","cljs.core.assoc","zprint.guide/constant-or-vector?","element","cljs.core/Keyword","p__49867","vec__49868","zprint.guide/count-constants","constant-count","possible-constant?","cljs.core/not","cljs.core/reduced","G__49878","zprint.guide/moustacheguide","vec__49880","rev-sexpr","cljs.core/reverse","_","cljs.core.reduce","pair-count","pair-guide","non-pair-count","non-pair-guide","cljs.core.interpose","cljs.core.concat","or__5045__auto__","cljs.core.println","zprint.guide/add-double-quotes","s","G__49892","zprint.guide/areguide","are-options","zprint.guide.areguide","justify?","max-variance","caller-options","fexpr__49893","current-indent","are-indent","table-indent","arg-vec-len","cljs.core/second","test-len","rows","excess-tests","alignment-vec","zfn-map","zloc-seq-nc","G__49902","G__49903","fexpr__49901","cljs.core/identity","args","cljs.core.drop","arg-strs","cljs.core.mapv","seq-of-seqs","cljs.core.partition","max-width-vec","zprint.util.column_alignment","zprint.util/cumulative-alignment","mark-guide","cljs.core/vec","cljs.core/flatten","cljs.core/vector","cljs.core.range","new-row-guide","G__49906","cljs.core/empty?","multi-row-guide","cljs.core.apply","cljs.core/concat","G__49910","G__49918","zprint.guide/areguide-basic","beginning","cljs.core.take","single-row","row-guide","G__49921","G__49934","zprint.guide/jrequireguide","keyword","vectors+lists","p1__49932#","cljs.core.filter","cljs.core/list?","max-first","element-guide","vector-guide","G__49959","zprint.guide/rumguide","vec__49963","up-to-arguments","args-and-after","p1__49956#","cljs.core/split-with","lt","lt?","mixin-indent","beginning-guide","middle-element-count","middle-guide","end-element-count","end-guide","G__49976","zprint.guide/rumguide-1","vec__49977","p1__49971#","G__49988","zprint.guide/rumguide-2","vec__49989","p1__49983#","G__50006","zprint.guide/odrguide","vec__50008","vec__50011","vec__50014","vectors","beyond","alignment-guide","keyword-1","keyword-1-lists","keyword-2","keyword-2-lists","G__50020","zprint.guide/guide-arg-count","zprint.guide/guide-insert","p__50036","vec__50037","zprint.guide/handle-args","running-arg-count","command","command-arg-count","before","after","G__50043","G__50052","zprint.guide/guideguide","G__50058","G__50065","zprint.guide/defprotocolguide","vec__50072","third","fourth","fifth","docstring","option","option-value","G__50078","G__50086","zprint.guide/signatureguide1","cljs.core/conj"],"sourcesContent":["(ns ^:no-doc zprint.guide\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer\n               [dbg dbg-s dbg-pr dbg-s-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg-s-pr dbg dbg-s dbg-form dbg-print zfuture]]])\n            [clojure.string :as s]\n            [rewrite-clj.zip :as z]\n            [zprint.util :refer [column-alignment cumulative-alignment]]))\n\n;;\n;; Contains functions which can be called with {:option-fn <fn>} to produce\n;; a \"guide\", which is, roughtly, a sequence comprised of keywords\n;; which describe how to format an expression.  A guide must be created\n;; explicitly for the expression to be formatted.\n;;\n;; For instance, this expression: (a b c d e f g) could be formatted\n;; for this output:\n;;\n;; (a b c\n;;  d e f\n;;  g)\n;;\n;; by this guide:\n;;\n;; [:element :element :element :newline :element :element :element :newline\n;;  :element]\n;;          \n;; There are a lot more keywords and other things which can be in a guide\n;; than demonstrated above.\n\n;;\n;; # Guide for \"rules of defn\", an alternative way to format defn expressions.\n;;\n\n(defn rodguide\n  \"Given a structure which starts with defn, create a guide for the\n  'rules of defn', an alternative approach to formatting a defn.\"\n  ([] \"rodguide\")\n  ; If you call a guide with partial because it has its own options map,\n  ; the \"no-argument\" arity must include the options map!\n  ([rod-options] \"rodguide\")\n  ; Since we have released this before, we will also allow it to be called\n  ; without are-options\n  ([options len sexpr] (rodguide {} options len sexpr))\n  ([rod-options options len sexpr]\n   (when (= (str (first sexpr)) \"defn\")\n     (let [multi-arity-nl? (get rod-options :multi-arity-nl? true)\n           docstring? (string? (nth sexpr 2))\n           rest (nthnext sexpr (if docstring? 3 2))\n           multi-arity? (not (vector? (first rest)))\n           rest (if multi-arity? rest (next rest))\n           rest-guide (repeat (dec (count rest)) :element)\n           rest-guide\n             (into []\n                   (if (and multi-arity? multi-arity-nl?)\n                     (interleave rest-guide (repeat :newline) (repeat :newline))\n                     (interleave rest-guide (repeat :newline))))\n           ; Make interleave into interpose\n           rest-guide (conj rest-guide :element)\n           guide (cond-> [:element :element]\n                   docstring? (conj :newline :element :newline)\n                   (not multi-arity?) (conj :element :newline)\n                   (and multi-arity? (not docstring?)) (conj :newline)\n                   :rest (into rest-guide))\n           option-map {:guide guide, :next-inner {:list {:option-fn nil}}}]\n       (if multi-arity?\n         (assoc option-map\n           :next-inner {:list {:option-fn nil},\n                        :fn-map {:vector :force-nl},\n                        :next-inner-restore [[:fn-map :vector]]})\n         option-map)))))\n\n; Use this to use the above:\n;\n; (czprint rod4\n;    {:parse-string? true\n;     :fn-map {\"defn\" [:guided {:list {:option-fn rodguide}}]}})\n\n;;\n;; # Guide to replicate the existing output for {:style :moustache}\n;;\n\n(defn constant-or-vector?\n  \"Return true if a constant or vector.\"\n  [element]\n  #_(println \"c-or-v?\" element)\n  (or (number? element)\n      (string? element)\n      (vector? element)\n      (keyword? element)\n      (= element true)\n      (= element false)))\n\n(defn count-constants\n  [[constant-count possible-constant?] element]\n  (if possible-constant?\n    (if (constant-or-vector? element)\n      [(inc constant-count) (not possible-constant?)]\n      (reduced [constant-count possible-constant?]))\n    [constant-count (not possible-constant?)]))\n\n(defn moustacheguide\n  \"Reimplement :style :moustache with guides.\"\n  ([] \"moustacheguide\")\n  ([options len sexpr]\n   ; First, find the pairs.\n   (let [rev-sexpr (reverse sexpr)\n         [constant-count _] (reduce count-constants [0 false] rev-sexpr)\n         pair-count (* constant-count 2)\n         pair-guide (into [] (repeat pair-count :element))\n         pair-guide (conj pair-guide :group-end)\n         pair-guide (conj pair-guide :element-pair-group)\n         non-pair-count (- (count sexpr) pair-count)\n         non-pair-guide (repeat non-pair-count :element)\n         non-pair-guide (into [] (interpose :newline non-pair-guide))\n         guide (conj non-pair-guide :newline :group-begin)\n         guide (concat guide pair-guide)]\n     (dbg-s options\n            :guide\n            \"moustacheguide: sexpr\" sexpr\n            \"pair-count:\" pair-count\n            \"output:\" guide)\n     {:guide guide,\n      :pair {:justify? true},\n      :next-inner {:pair {:justify? false}, :list {:option-fn nil}}})))\n\n; Use this to use the above:\n;\n;(czprint mapp6g\n;   {:parse-string? true\n;    :fn-map {\"m/app\" [:guided {:list {:option-fn moustacheguide}}]}})\n\n\n;;\n;; # Guide for the \"are\" function\n;;\n\n(defn add-double-quotes\n  \"Given two arguments, an s-expression and a string, if the s-expression\n  is actually a string, add a double quote on to the beginning and end of\n  the string.\"\n  [sexpr s]\n  (if (string? sexpr) (str \"\\\"\" s \"\\\"\") s))\n\n(defn areguide\n  \"Format are test functions.  Call it with (partial {} areguide), where\n  the map can be {:justify? true} to justify the various rows. It will\n  use {:pair {:justify {:max-variance n}}} for the variance, but you can\n  give it a variance to use with {:max-variance n} in the map which is\n  its first argument.\"\n  ([] \"areguide\")\n  ; If you call a guide with partial because it has its own options map,\n  ; the \"no-argument\" arity must include the options map!\n  ([are-options] \"areguide\")\n  ; Since we have released this before, we will also allow it to be called\n  ; without are-options\n  ([options len sexpr] (areguide {} options len sexpr))\n  ([are-options options len sexpr]\n   (let [justify? (:justify? are-options)\n         max-variance (when justify?\n                        (or (:max-variance are-options)\n                            (:max-variance (:justify (:pair options)))))\n         caller-options ((:caller options) options)\n         current-indent (or (:indent-arg caller-options)\n                            (:indent caller-options))\n         are-indent (:indent are-options)\n         table-indent (+ current-indent (or are-indent current-indent))\n         arg-vec-len (count (second sexpr))\n         test-len (- (count sexpr) 3)\n         rows (/ test-len arg-vec-len)\n         excess-tests (- test-len (* rows arg-vec-len))\n         alignment-vec\n           (when justify?\n             (let [; zloc-seq no comments\n                   zfn-map (:zfn-map options)\n                   zloc-seq-nc\n                     ((:zmap-no-comment zfn-map) identity (:zloc options))\n                   args (drop 3 zloc-seq-nc)\n                   ; Get the lengths of the actual zloc values, not the sexpr\n                   arg-strs (mapv (:zstring zfn-map) args)\n                   #_(prn \"early arg-strs:\" arg-strs)\n                   ; This makes strings too long, but it was\n                   ; presumably added for some reason?  Issue #212\n                   ; arg-strs (mapv add-double-quotes (drop 3 sexpr) arg-strs)\n                   #_(prn \"later arg-strs:\" arg-strs)\n                   seq-of-seqs (partition arg-vec-len arg-vec-len [] arg-strs)\n                   max-width-vec (column-alignment max-variance\n                                                   seq-of-seqs\n                                                   nil\n                                                   :no-string-adj?)\n                   alignment-vec (cumulative-alignment max-width-vec)]\n               #_(prn \"max-width-vec:\" max-width-vec\n                      \"alignment-vec:\" alignment-vec)\n               alignment-vec))\n         mark-guide\n           (vec (flatten\n                  (mapv vector (repeat :mark-at-indent) (range) alignment-vec)))\n         new-row-guide (cond-> [:element :indent table-indent]\n                         (not (empty? alignment-vec))\n                           (into (interleave (repeat :align)\n                                             (range (count alignment-vec))\n                                             (repeat :element)))\n                         (empty? alignment-vec) (into (repeat (dec arg-vec-len)\n                                                              :element))\n                         true (conj :indent-reset :newline))\n         multi-row-guide (apply concat (repeat rows new-row-guide))\n         guide (cond-> (-> [:element :element :element-best :newline]\n                           (into mark-guide)\n                           (into multi-row-guide))\n                 (pos? excess-tests) (conj :element-*))]\n     #_(prn \"guide:\" guide)\n     {:guide guide, :next-inner {:list {:option-fn nil}}})))\n\n(defn areguide-basic\n  \"Format are test functions, no justification.\"\n  ([] \"areguide\")\n  ([options len sexpr]\n   (let [arg-vec-len (count (second sexpr))\n         beginning (take 3 sexpr)\n         test-len (- (count sexpr) 3)\n         rows (/ test-len arg-vec-len)\n         excess-tests (- test-len (* rows arg-vec-len))\n         single-row (into [:newline] (repeat arg-vec-len :element))\n         row-guide (apply concat (repeat rows single-row))\n         guide (cond-> (-> [:element :element :element-best]\n                           (into row-guide))\n                 (pos? excess-tests) (conj :newline :element-*))]\n     {:guide guide, :next-inner {:list {:option-fn nil}}})))\n\n\n; Do this to use the above:\n;\n; (czprint are3\n;   {:parse-string? true\n;    :fn-map {\"are\" [:guided {:list {:option-fn areguide}}]}})\n;\n\n;;\n;; # Guide to justify the content of the vectors in a (:require ...)\n;;\n\n;\n; A much simpler version of the require guide.  This version doesn't require\n; use of the call-stack, and has only one option-fn instead of two.  It also\n; uses the new variance-based justification capabilities.\n;\n\n(defn jrequireguide\n  \"Justify the first things in a variety of settings.  The first argument\n  is the things to recognize, and can be :require, :require-macros, or \n  :import. :require and :require-macros are handled the same, and :import\n  is handled differently since it has the values all in the same expression.\n  Handles sequences with lists or vectors.\"\n  ([] \"jrequireguide\")\n  ; If you call a guide with partial because it has its a required first\n  ; argument, ; the \"no-argument\" arity must include the first argument!\n  ([keyword] \"jrequireguide\")\n  ([keyword options len sexpr]\n   (when (= (first sexpr) keyword)\n     (let [vectors+lists (filter #(or (vector? %) (list? %)) sexpr)]\n       (when (not (empty? vectors+lists))\n         (let [max-width-vec (column-alignment (:max-variance\n                                                 (:justify (:pair options)))\n                                               vectors+lists\n                                               ; only do the first column\n                                               1)\n               _ (dbg-s options\n                        :guide\n                        \"jrequireguide max-width-vec:\"\n                        max-width-vec)\n               max-first (first max-width-vec)\n               element-guide :element-pair-*\n               vector-guide (if max-first\n                              (if (= (first sexpr) :import)\n                                [:mark-at 0 (inc max-first) :element :align 0\n                                 :indent-here #_(+ max-first 2) :element-*]\n                                [:mark-at 0 (inc max-first) :element :align 0\n                                 element-guide])\n                              ; We can't justify things, fall back to this.\n                              [:element element-guide])]\n           ; Do this for all of the first level vectors and lists  below the\n           ; :require, but no other vectors or lists more deeply nested.\n           {:next-inner {:vector {:option-fn (fn [_ _ _] {:guide vector-guide}),\n                                  :wrap-multi? true,\n                                  :hang? true},\n                         :list {:option-fn (fn [_ _ _] {:guide vector-guide}),\n                                :wrap-multi? true,\n                                :hang? true},\n                         :pair {:justify? true},\n                         :next-inner-restore\n                           [[:vector :option-fn] [:vector :wrap-multi?]\n                            [:vector :hang?] [:list :option-fn]\n                            [:list :wrap-multi?] [:list :hang?]\n                            [:pair :justify?]]}}))))))\n\n; Do this to use the above:\n;\n; (czprint jr1\n;    {:parse-string? true\n;    :fn-map {\":require\" [:none {:list {:option-fn jrequireguide}}]}})\n\n;;\n;; # Guide to replicate the output of :arg1-mixin\n;; \n\n(defn rumguide\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :spaces.  For guide testing, do not use this as a model\n  for how to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             mixin-indent (if lt? 2 1)\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide\n               (if (pos? middle-element-count)\n                 (if lt? [:element :element :newline] [:element :newline])\n                 [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:spaces mixin-indent :element\n                                           :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n(defn rumguide-1\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :align.  For guide testing, do not use this as a model\n  for how to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide (if (pos? middle-element-count)\n                            (if lt?\n                              [:element :mark 1 :align 1 :element :newline]\n                              [:mark 1 :align 1 :element :newline])\n                            [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:align 1 :element :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n(defn rumguide-2\n  \"Assumes that this is rum/defcs or something similar. Implement :arg1-mixin\n  with guides using :indent.  This is probably the simplest and therefore the\n  best of them all.  For guide testing, do not use this as a model for how\n  to write a guide.\"\n  ([] \"rumguide\")\n  ([options len sexpr]\n   (let [docstring? (string? (nth sexpr 2))\n         [up-to-arguments args-and-after]\n           (split-with #(not (or (vector? %)\n                                 (and (list? %) (vector? (first %)))))\n                       sexpr)\n         #_(println \"rumguide: up-to-arguments:\" up-to-arguments\n                    \"\\nargs-and-after:\" args-and-after)]\n     (if (empty? args-and-after)\n       {:list {:option-fn nil}}\n       (let [lt (nth sexpr (if docstring? 3 2))\n             lt? (= (str lt) \"<\")\n             beginning-guide [:element :element :newline]\n             beginning-guide (if docstring?\n                               (concat beginning-guide [:element :newline])\n                               beginning-guide)\n             middle-element-count\n               (- (count up-to-arguments) 2 (if docstring? 1 0) (if lt? 1 0))\n             middle-guide (if (pos? middle-element-count)\n                            (if lt?\n                              [:element :indent 4 :element :newline]\n                              [:indent 4 :element :newline])\n                            [])\n             #_(println \"middle-element-count:\" middle-element-count)\n             middle-guide (concat middle-guide\n                                  (repeat (dec middle-element-count)\n                                          [:element :newline]))\n             end-element-count (count args-and-after)\n             end-guide [:indent-reset :element\n                        (repeat (dec end-element-count) [:newline :element])]\n             guide (concat beginning-guide middle-guide end-guide)\n             ; This could have been done so flatten wasn't necessary\n             ; but it for testing it wasn't worth the re-work.\n             guide (flatten guide)\n             #_(println \"rumguide: guide:\" guide)]\n         {:guide guide, :next-inner {:list {:option-fn nil}}})))))\n\n\n; Do this to use the above:\n;\n; (czprint cz8x1\n;     {:parse-string? true\n;     :fn-map {\"rum/defcs\" [:guided {:list {:option-fn rumguide}}]}})\n\n(defn odrguide\n  \"Justify O'Doyles Rules\"\n  ([] \"odrguide\")\n  ([options len sexpr]\n   (when (= (first sexpr) :what)\n     (let [[vectors beyond] (split-with vector? (next sexpr))\n           max-width-vec (column-alignment (:max-variance (:justify (:pair\n                                                                      options)))\n                                           vectors)\n           alignment-vec (cumulative-alignment max-width-vec)\n           mark-guide\n             (vec (flatten\n                    (mapv vector (repeat :mark-at) (range) alignment-vec)))\n           alignment-guide\n             (mapv vector (repeat :align) (range (count alignment-vec)))\n           vector-guide (into mark-guide\n                              (flatten [(interleave (repeat :element)\n                                                    alignment-guide)\n                                        :element-*]))\n           keyword-1 (first beyond)\n           [keyword-1-lists beyond] (split-with list? (next beyond))\n           keyword-2 (first beyond)\n           [keyword-2-lists beyond] (split-with list? (next beyond))\n           _ (dbg-s options\n                    :guide\n                    \"odrguide alignment-vec:\" alignment-vec\n                    \"mark-guide:\" mark-guide\n                    \"alignment-guide:\" alignment-guide\n                    \"vector-guide:\" vector-guide\n                    \"keyword-1:\" keyword-1\n                    \"keyword-1-lists:\" keyword-1-lists\n                    \"keyword-2:\" keyword-2\n                    \"keyword-2-lists:\" keyword-2-lists)\n           guide (cond->\n                   (-> [:element :indent 2 :options\n                        {:guide vector-guide,\n                         :vector {:wrap-multi? true, :hang? true}} :group-begin]\n                       (into (repeat (count vectors) :element))\n                       (conj :group-end\n                             :element-newline-best-group :options-reset\n                             :options {:vector {:wrap-multi? true, :hang? true}}\n                             :indent 1))\n                   keyword-1 (conj :newline :element)\n                   (not (empty? keyword-1-lists))\n                     (-> (conj :indent 2 :group-begin)\n                         (into (repeat (count keyword-1-lists) :element))\n                         (conj :group-end :element-newline-best-group\n                               :indent 1))\n                   keyword-2 (conj :newline :element)\n                   (not (empty? keyword-2-lists))\n                     (-> (conj :indent 2 :group-begin)\n                         (into (repeat (count keyword-2-lists) :element))\n                         (conj :group-end :element-newline-best-group)))]\n       (dbg-s options :guide \"odrguide:\" guide)\n       {:guide guide}))))\n\n;;\n;; Guide guide\n;;\n\n(def guide-arg-count\n  {:element 0,\n   :element-* 0,\n   :element-best 0,\n   :element-best-* 0,\n   :element-pair-group 0,\n   :element-pair-* 0,\n   :element-newline-best-group 0,\n   :element-newline-best-* 0,\n   :element-binding-group 0,\n   :element-binding-* 0,\n   :element-guide 1,\n   :element-binding-vec 0,\n   :newline 0,\n   :options 1,\n   :options-reset 0,\n   :indent 1,\n   :indent-reset 0,\n   :spaces 1,\n   :mark-at 2,\n   :mark-at-indent 2,\n   :mark 1,\n   :align 1,\n   :group-begin 0,\n   :group-end 0})\n\n(def guide-insert\n  {:group-begin {:after [:indent 3]}, :group-end {:before [:indent 1]}})\n\n(defn handle-args\n  \"Figure out the arg-count for a guide.\"\n  [[guide running-arg-count] command]\n  (if (zero? running-arg-count)\n    (let [command-arg-count (or (guide-arg-count command) 0)\n          before (:before (guide-insert command))\n          after (:after (guide-insert command))]\n      [(cond-> guide\n         before (into before)\n         (empty? guide) (conj :element)\n         (not (empty? guide)) (conj :newline :element)\n         after (into after)) command-arg-count])\n    [(conj guide :element) (dec running-arg-count)]))\n\n(defn guideguide\n  \"Print out a guide\"\n  ([] \"guideguide\")\n  ([options len sexpr]\n   (when (guide-arg-count (first sexpr))\n     {:guide (first (reduce handle-args [[] 0] sexpr))})))\n\n;;\n;; Real guide for defprotocol\n;;\n\n(declare signatureguide1)\n\n(defn defprotocolguide\n  \"Handle defprotocol with options.\"\n  ([] \"defprotocolguide\")\n  ([options len sexpr]\n   (when (= (first sexpr) 'defprotocol)\n     (let [third (nth sexpr 2 nil)\n           fourth (nth sexpr 3 nil)\n           fifth (nth sexpr 4 nil)\n           [docstring option option-value]\n             (cond (and (string? third) (keyword? fourth)) [third fourth fifth]\n                   (string? third) [third nil nil]\n                   (keyword? third) [nil third fourth]\n                   :else [nil nil nil])\n           guide (cond-> [:element :element-best :newline]\n                   docstring (conj :element :newline)\n                   option (conj :element :element :newline)\n                   :else (conj :element-newline-best-*))]\n       {:guide guide, :next-inner {:list {:option-fn nil}}}))))\n\n(defn signatureguide1\n  \"Handle defprotocol signatures with arities and doc string on their \n  own lines.\"\n  ([] \"signatureguide1\")\n  ([options len sexpr]\n   (let [vectors (filter vector? sexpr)\n         guide [:element :group-begin]\n         guide (apply conj guide (repeat (count vectors) :element))\n         guide (conj guide\n                     :group-end :element-newline-best-group\n                     :newline :element-*)]\n     {:guide guide})))\n\n"]}