{"version":3,"sources":["sci/core.cljc"],"mappings":"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","names":["var_args","G__65431","sci.core/new-var","js/Error","name","G__65432","sci.core.new_var","sci.impl.vars/unbind","init-val","cljs.core/meta","meta","sci.impl.vars/SciVar","G__65436","sci.core/new-dynamic-var","G__65437","sci.core.new_dynamic_var","cljs.core.assoc","sci.core/set!","dynamic-var","v","sci.impl.types/setVal","G__65442","sci.core/new-macro-var","sci.core.new_macro_var","cljs.core.vary_meta","cljs.core/assoc","sci.core/in","sci.impl.io/in","sci.core/out","sci.impl.io/out","sci.core/err","sci.impl.io/err","sci.core/ns","sci.impl.vars/current-ns","sci.core/file","sci.impl.vars/current-file","sci.core/print-length","sci.impl.io/print-length","sci.core/print-level","sci.impl.io/print-level","sci.core/print-meta","sci.impl.io/print-meta","sci.core/print-readably","sci.impl.io/print-readably","sci.core/print-fn","sci.impl.io/print-fn","sci.core/print-newline","sci.impl.io/print-newline","sci.core/*1","sci.impl.namespaces/*1","sci.core/*2","sci.impl.namespaces/*2","sci.core/*3","sci.impl.namespaces/*3","sci.core/*e","sci.impl.namespaces/*e","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","sci.core/alter-var-root","seq65463","G__65464","cljs.core/first","cljs.core/next","G__65465","self__5754__auto__","f","args","cljs.core.apply","sci.impl.vars/alter-var-root","G__65468","sci.core/intern","ctx","sci-ns","sci.impl.namespaces.sci_intern","val","G__65470","sci.core/eval-string","s","sci.core.eval_string","opts","sci.impl.interpreter.eval_string","sci.core/init","sci.impl.opts/init","sci.core/merge-opts","sci.impl.opts/merge-opts","sci.core/fork","cljs.core.update","env","cljs.core/deref","cljs.core.atom","sci.core/eval-string*","sci.impl.interpreter/eval-string*","G__65479","sci.core/create-ns","sym","sci.core.create_ns","sci.impl.vars/->SciNamespace","sci.core/parse-string","sci.impl.parser/parse-string","sci.core/reader","x","sci.impl.parser/reader","sci.core/get-line-number","reader","sci.impl.parser/get-line-number","sci.core/get-column-number","sci.impl.parser/get-column-number","G__65485","sci.core/parse-next","sci.core.parse_next","sci.impl.parser.parse_next","sci.impl.utils/kw-identical?","sci.impl.parser/eof","or__5045__auto__","cljs.core.get","sci.core/eval-form","form","cljs.core.gensym","sci.impl.interpreter/eval-form","sci.core/stacktrace","ex","G__65490","cljs.core/ex-data","sci.impl.callstack/stacktrace","sci.core/format-stacktrace","stacktrace","sci.impl.callstack/format-stacktrace","sci.core/ns-name","sci.impl.namespaces/sci-ns-name","sci.core/-copy-ns","ns-publics-map","cljs.core.reduce","p__65491","vec__65492","cljs.core.nth","ns-map","var-name","var","m","cljs.core.symbol","p__65495","map__65496","cljs.core/--destructure-map","sci.core/process-publics","publics","exclude","cljs.core/dissoc","sci.core/exclude-when-meta","publics-map","meta-fn","key-fn","val-fn","skip-keys","p__65497","vec__65498","cljs.core/some","sci.core/meta-fn","p1__65501#","p1__65502#","cljs.core._EQ_","cljs.core/identity","cljs.core/select-keys"],"sourcesContent":["(ns sci.core\n  (:refer-clojure :exclude [with-bindings with-in-str with-out-str\n                            with-redefs binding future pmap alter-var-root\n                            intern ns create-ns set! *1 *2 *3 *e\n                            ns-name])\n  (:require\n   [sci.impl.callstack :as cs]\n   [sci.impl.interpreter :as i]\n   [sci.impl.io :as sio]\n   [sci.impl.macros :as macros]\n   [sci.impl.namespaces :as namespaces]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as parser]\n   [sci.impl.types :as t]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars])\n  #?(:cljs (:require-macros\n            [sci.core :refer [with-bindings with-out-str copy-var copy-ns]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn new-var\n  \"Returns a new sci var.\"\n  ([name] (doto (new-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name meta false)))\n\n(defn new-dynamic-var\n  \"Same as new-var but adds :dynamic true to meta.\"\n  ([name] (doto (new-dynamic-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-dynamic-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name (assoc meta :dynamic true) false)))\n\n(defn set!\n  \"Establish thread local binding of dynamic var\"\n  [dynamic-var v]\n  (t/setVal dynamic-var v))\n\n(defn new-macro-var\n  \"Same as new-var but adds :macro true to meta as well\n  as :sci/macro true to meta of the fn itself.\"\n  ([name init-val] (new-macro-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar.\n                         (vary-meta init-val\n                                    assoc :sci/macro true)\n                         name (assoc meta :macro true) false)))\n\n(defmacro copy-var\n  \"Copies contents from var `sym` to a new sci var. The value `ns` is an\n  object created with `sci.core/create-ns`.\"\n  ([sym ns]\n   `(let [ns# ~ns\n          var# (var ~sym)\n          val# (deref var#)\n          m# (-> var# meta)\n          ns-name# (vars/getName ns#)\n          name# (:name m#)\n          name-sym# (symbol (str ns-name#) (str name#))\n          new-m# {:doc (:doc m#)\n                  :name name#\n                  :arglists (:arglists m#)\n                  :ns ns#}]\n      (cond (:dynamic m#)\n            (new-dynamic-var name# val# new-m#)\n            (:macro m#)\n            (new-macro-var name# val# new-m#)\n            :else (new-var name# val# new-m#)))))\n\n(macros/deftime\n  (defmacro with-bindings\n    \"Macro for binding sci vars. Must be called with map of sci dynamic\n  vars to values. Used in babashka.\"\n    [bindings-map & body]\n    `(let [bm# ~bindings-map]\n       (assert (map? bm#))\n       (vars/push-thread-bindings bm#) ;; important: outside try\n       (try\n         (do ~@body)\n         (finally (vars/pop-thread-bindings)))))\n\n  (defmacro binding\n    \"Macro for binding sci vars. Must be called with a vector of sci\n  dynamic vars to values.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    (assert (even? (count bindings)))\n    `(with-bindings ~(apply hash-map bindings)\n       (do ~@body))))\n\n;; I/O\n(def in \"Sci var that represents sci's `clojure.core/*in*`\" sio/in)\n(def out \"Sci var that represents sci's `clojure.core/*out*`\" sio/out)\n(def err \"Sci var that represents sci's `clojure.core/*err*`\" sio/err)\n(def ns \"Sci var that represents sci's `clojure.core/*ns*`\" vars/current-ns)\n(def file \"Sci var that represents sci's `clojure.core/*file*`\" vars/current-file)\n(def print-length \"Sci var that represents sci's `clojure.core/*print-length*`\" sio/print-length)\n(def print-level \"Sci var that represents sci's `clojure.core/*print-level*`\" sio/print-level)\n(def print-meta \"Sci var that represents sci's `clojure.core/*print-meta*`\" sio/print-meta)\n(def print-readably \"Sci var that represents sci's `clojure.core/*print-readably*`\" sio/print-readably)\n#?(:cljs (def print-fn \"Sci var that represents sci's `cljs.core/*print-fn*`\" sio/print-fn))\n#?(:cljs (def print-newline \"Sci var that represents sci's `cljs.core/*print-newline*`\" sio/print-newline))\n\n(def *1 namespaces/*1)\n(def *2 namespaces/*2)\n(def *3 namespaces/*3)\n(def *e namespaces/*e)\n\n;; REPL variables\n\n\n(macros/deftime\n  (defmacro with-in-str\n    \"Evaluates body in a context in which sci's *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n    [s & body]\n    `(let [in# (-> (java.io.StringReader. ~s)\n                   (clojure.lang.LineNumberingPushbackReader.))]\n       (with-bindings {in in#}\n         (do ~@body)))))\n\n(macros/deftime\n  (defmacro with-out-str\n    \"Evaluates exprs in a context in which sci's *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n    [& body]\n    (macros/? :clj\n              `(let [out# (java.io.StringWriter.)]\n                 (with-bindings {out out#}\n                   (do ~@body)\n                   (str out#)))\n              :cljs\n              `(let [sb# (goog.string/StringBuffer.)]\n                 (cljs.core/binding []\n                   (with-bindings {sci.core/print-newline true\n                                   sci.core/print-fn (fn [x#] (.append sb# x#))}\n                     (do ~@body)\n                     (str sb#)))))))\n\n(macros/deftime\n  (defmacro future\n    \"Like clojure.core/future but also conveys sci bindings to the thread.\"\n    [& body]\n    `(let [f# (-> (fn [] ~@body)\n                  (vars/binding-conveyor-fn))]\n       (future-call f#))))\n\n#?(:clj (defn pmap\n          \"Like clojure.core/pmap but also conveys sci bindings to the threads.\"\n          ([f coll]\n           (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n                 rets (map #(future (f %)) coll)\n                 step (fn step [[x & xs :as vs] fs]\n                        (lazy-seq\n                         (if-let [s (seq fs)]\n                           (cons (deref x) (step xs (rest s)))\n                           (map deref vs))))]\n             (step rets (drop n rets))))\n          ([f coll & colls]\n           (let [step (fn step [cs]\n                        (lazy-seq\n                         (let [ss (map seq cs)]\n                           (when (every? identity ss)\n                             (cons (map first ss) (step (map rest ss)))))))]\n             (pmap #(apply f %) (step (cons coll colls)))))))\n\n(defn alter-var-root\n  \"Atomically alters the root binding of sci var v by applying f to its\n  current value plus any args.\"\n  [v f & args]\n  (apply vars/alter-var-root v f args))\n\n(defn intern\n  \"Finds or creates a sci var named by the symbol name in the namespace\n  ns (which can be a symbol or a sci namespace), setting its root\n  binding to val if supplied. The namespace must exist in the ctx. The\n  sci var will adopt any metadata from the name symbol.  Returns the\n  sci var.\"\n  ([ctx sci-ns name]\n   (namespaces/sci-intern ctx sci-ns name))\n  ([ctx sci-ns name val]\n   (namespaces/sci-intern ctx sci-ns name val)))\n\n(defn eval-string\n  \"Evaluates string `s` as one or multiple Clojure expressions using the Small Clojure Interpreter.\n\n  The map `opts` may contain the following:\n\n  - `:namespaces`: a map of symbols to namespaces, where a namespace\n  is a map with symbols to values, e.g.: `{'foo.bar {'x 1}}`. These\n  namespaces can be used with `require`.\n\n  - `:bindings`: `:bindings x` is the same as `:namespaces {'user x}`.\n\n  - `:allow`: a seqable of allowed symbols. All symbols, even those\n  brought in via `:bindings` or `:namespaces` have to be explicitly\n  enumerated.\n\n  - `:deny`: a seqable of disallowed symbols, e.g.: `[loop quote\n  recur]`.\n\n  - `:features`: when provided a non-empty set of keywords, sci will process reader conditionals using these features (e.g. #{:bb}).\n\n  - `:env`: an atom with a map in which state from the\n  evaluation (defined namespaced and vars) will be persisted for\n  re-use over multiple calls.\n\n  - `:disable-arity-checks`: disables arity checks for single-arity\n  functions.\"\n  ([s] (eval-string s nil))\n  ([s opts]\n   (i/eval-string s opts)))\n\n(defn init\n  \"Creates an initial sci context from given options `opts`. The context\n  can be used with `eval-string*`. See `eval-string` for available\n  options. The internal organization of the context is implementation\n  detail and may change in the future.\"\n  [opts]\n  (opts/init opts))\n\n(defn merge-opts\n  \"Updates a context with opts merged in and returns it.\"\n  [ctx opts]\n  (opts/merge-opts ctx opts))\n\n(defn fork\n  \"Forks a context (as produced with `init`) into a new context. Any new\n  vars created in the new context won't be visible in the original\n  context.\"\n  [ctx]\n  (update ctx :env (fn [env] (atom @env))))\n\n(defn eval-string*\n  \"Evaluates string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  [ctx s]\n  (sci.impl.interpreter/eval-string* ctx s))\n\n(defn create-ns\n  \"Creates namespace object. Can be used in var metadata.\"\n  ([sym] (create-ns sym nil))\n  ([sym meta]\n   (vars/->SciNamespace sym meta)))\n\n(defn parse-string\n  \"Parses string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  ([ctx s]\n   (parser/parse-string ctx s)))\n\n(defn reader\n  \"Coerces x into indexing pushback-reader to be used with\n  parse-next. Accepts: string or java.io.Reader.\"\n  [x]\n  (parser/reader x))\n\n(defn get-line-number [reader]\n  (parser/get-line-number reader))\n\n(defn get-column-number [reader]\n  (parser/get-column-number reader))\n\n(defn parse-next\n  \"Parses next form from reader\"\n  ([ctx reader] (parse-next ctx reader {}))\n  ([ctx reader opts]\n   (let [v (parser/parse-next ctx reader opts)]\n     (if (utils/kw-identical? parser/eof v)\n       (or (get opts :eof)\n           ::eof)\n       v))))\n\n(defn eval-form\n  \"Evaluates form (as produced by `parse-string` or `parse-next`) in the\n  context of `ctx` (as produced with `init`). To allow namespace\n  switches, establish root binding of `sci/ns` with `sci/binding` or\n  `sci/with-bindings.`\"\n  [ctx form]\n  (let [ctx (assoc ctx :id (or (:id ctx) (gensym)))]\n    (i/eval-form ctx form)))\n\n(defn stacktrace\n  \"Returns list of stacktrace element maps from exception, if available.\"\n  [ex]\n  (some-> ex ex-data :sci.impl/callstack cs/stacktrace))\n\n(defn format-stacktrace\n  \"Returns a list of formatted stack trace elements as strings from stacktrace.\"\n  [stacktrace]\n  (cs/format-stacktrace stacktrace))\n\n(defn ns-name\n  \"Returns name of SCI ns as symbol.\"\n  [sci-ns]\n  (namespaces/sci-ns-name sci-ns))\n\n(defn -copy-ns\n  {:no-doc true}\n  [ns-publics-map sci-ns]\n  (reduce (fn [ns-map [var-name var]]\n            (let [m (:meta var)]\n              (assoc ns-map var-name\n                     (new-var (symbol var-name) (:val var)\n                              (assoc m :ns sci-ns)))))\n          {}\n          ns-publics-map))\n\n(defn- process-publics [publics {:keys [exclude]}]\n  (let [publics (if exclude (apply dissoc publics exclude) publics)]\n    publics))\n\n(defn- exclude-when-meta [publics-map meta-fn key-fn val-fn skip-keys ]\n  (reduce (fn [ns-map [var-name var]]\n            (let [m (meta-fn var)]\n              (if (some m skip-keys)\n                ns-map\n                (assoc ns-map (key-fn var-name) (val-fn var m)))))\n          {}\n          publics-map))\n\n(defn- meta-fn [opts]\n  (cond (= :all opts) identity\n        opts #(select-keys %  opts)\n        :else #(select-keys % [:arglists\n                               :no-doc\n                               :macro\n                               :doc])))\n\n(macros/deftime\n  (def ^:private cljs-ns-publics\n    (try (resolve 'cljs.analyzer.api/ns-publics)\n         (catch #?(:clj Exception\n                   :cljs :default) _ nil)))\n  (defmacro copy-ns\n    \"Returns map of names to SCI vars as a result of copying public\n  Clojure vars from ns-sym (a symbol). Attaches sci-ns (result of\n  sci/create-ns) to meta. Copies :name, :macro :doc, :no-doc\n  and :argslists metadata.\n\n  Options:\n\n  - :exclude: a seqable of names to exclude from the\n  namespace. Defaults to none.\n\n  - :copy-meta: a seqable of keywords to copy from the original var\n  meta.  Use :all instead of a seqable to copy all. Defaults\n  to [:doc :arglists :macro].\n\n  - :exclude-when-meta: seqable of keywords; vars with meta matching\n  these keys are excluded.  Defaults to [:no-doc :skip-wiki]\n\n  The selection of vars is done at compile time which is mostly\n  important for ClojureScript to not pull in vars into the compiled\n  JS. Any additional vars can be added after the fact with sci/copy-var\n  manually.\n\"\n    ([ns-sym sci-ns] `(copy-ns ~ns-sym ~sci-ns nil))\n    ([ns-sym sci-ns opts]\n     (macros/? :clj (let [publics-map (ns-publics ns-sym)\n                          publics-map (process-publics publics-map opts)\n                          mf (meta-fn (:copy-meta opts))\n                          publics-map (exclude-when-meta\n                                       publics-map\n                                       meta\n                                       (fn [k]\n                                         (list 'quote k))\n                                       (fn [var m]\n                                         {:name (list 'quote (:name m))\n                                          :val (deref var)\n                                          :meta (list 'quote (mf m))})\n                                       (or (:exclude-when-meta opts)\n                                           [:no-doc :skip-wiki]))]\n                      `(-copy-ns ~publics-map ~sci-ns))\n               :cljs (let [publics-map (cljs-ns-publics ns-sym)\n                           publics-map (process-publics publics-map opts)\n                           mf (meta-fn (:copy-meta opts))\n                           publics-map (exclude-when-meta\n                                        publics-map\n                                        :meta\n                                        (fn [k]\n                                          (list 'quote k))\n                                        (fn [var m]\n                                          {:name (list 'quote (:name var))\n                                           :val (:name var)\n                                           :meta (mf m)})\n                                        (or (:exclude-when-meta opts)\n                                            [:no-doc :skip-wiki]))]\n                       `(-copy-ns ~publics-map ~sci-ns))))))\n\n;;;; Scratch\n"]}