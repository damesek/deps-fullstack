{"version":3,"sources":["sci/impl/interpreter.cljc"],"mappings":"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","names":["sci.impl.interpreter/stats","cljs.core.atom","sci.impl.interpreter/update-stats","_ctx","k","t","cljs.core.swap_BANG_","stats","cljs.core.update","cljs.core/+","sci.impl.interpreter/print-stats","cljs.core.prn","cljs.core/zipmap","cljs.core/deref","cljs.core/keys","p1__64946#","cljs.core.map","cljs.core/vals","sci.impl.interpreter/eval-form","ctx","form","cljs.core/seq?","cljs.core._EQ_","cljs.core/first","exprs","cljs.core/rest","ret","cljs.core/seq","G__64951","G__64952","cljs.core/not","analyzed","sci.impl.analyzer.analyze","bindings","sci.impl.types/EvalForm","G__64953","G__64954","sci.impl.evaluator/eval","cljs.core/vreset!","sci.impl.utils/eval-form-state","sci.impl.interpreter/eval-string*","s","sci.impl.vars/push-thread-bindings","sci.impl.vars/pop-thread-bindings","sci.impl.vars/current-ns","reader","cljs.tools.reader.reader_types.indexing_push_back_reader","cljs.tools.reader.reader_types.string_push_back_reader","expr","sci.impl.parser.parse_next","sci.impl.utils/kw-identical?","sci.impl.parser/eof","sci.impl.utils/eval-string*","var_args","G__64956","sci.impl.interpreter/eval-string","js/Error","sci.impl.interpreter.eval_string","opts","init-ctx","sci.impl.opts/init"],"sourcesContent":["(ns sci.impl.interpreter\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-1])\n  (:require\n   [clojure.tools.reader.reader-types :as r]\n   [sci.impl.analyzer :as ana]\n   [sci.impl.evaluator :as eval]\n   [sci.impl.opts :as opts]\n   [sci.impl.parser :as p]\n   [sci.impl.types :as t]\n   [sci.impl.utils :as utils]\n   [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(def stats (atom {:parse 0 :analysis 0 :eval 0 :total 0}))\n(defn update-stats [_ctx k t]\n  (swap! stats (fn [stats]\n                 (-> stats\n                     (update k + t)\n                     (update :total + t)))))\n\n(defn print-stats []\n  (prn (zipmap (keys @stats)\n               (map #(/ (double %) 1000000.0) (vals @stats)))))\n\n(defn eval-form [ctx form]\n  (if (seq? form)\n    (if (= 'do (first form))\n      (loop [exprs (rest form)\n             ret nil]\n        (if (seq exprs)\n          (recur\n           (rest exprs)\n           (eval-form ctx (first exprs)))\n          ret))\n      (when (or (not (:uberscript ctx))\n                (= 'ns (first form))\n                (= 'require (first form)))\n        (let [analyzed (ana/analyze ctx form true)\n              bindings (:bindings ctx)\n              ret (if (instance? #?(:clj sci.impl.types.EvalForm\n                                    :cljs sci.impl.types/EvalForm) analyzed)\n                    (eval-form ctx (t/getVal analyzed))\n                    (eval/eval ctx bindings analyzed))]\n          ret)))\n    (let [analyzed (ana/analyze ctx form)\n          bindings (:bindings ctx)\n          ret (eval/eval ctx bindings analyzed)]\n      ret)))\n\n(vreset! utils/eval-form-state eval-form)\n\n(defn eval-string* [ctx s]\n  (vars/with-bindings {vars/current-ns @vars/current-ns}\n    (let [reader (r/indexing-push-back-reader (r/string-push-back-reader s))]\n      (loop [ret nil]\n        (let [expr (p/parse-next ctx reader)]\n          (if (utils/kw-identical? p/eof expr)\n            ret\n            (let [ret (eval-form ctx expr)]\n              (recur ret))))))))\n\n(vreset! utils/eval-string* eval-string*)\n\n;;;; Called from public API\n\n(defn eval-string\n  ([s] (eval-string s nil))\n  ([s opts]\n   (let [init-ctx (opts/init opts)\n         ret (eval-string* init-ctx s)]\n     ret)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"((fn f [x] (if (< x 3) (recur (inc x)) x)) 0)\")\n  )\n"]}